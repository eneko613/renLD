<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Renfe AV/LD Live Tracker</title>
    
    <!-- 1. Styles (Tailwind & Leaflet) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- 2. Libraries (React, DOM, Babel, Leaflet, Zip, CSV) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
        /* Custom styles that Tailwind doesn't cover easily */
        body { margin: 0; overflow: hidden; background-color: #f8fafc; }
        #map { width: 100vw; height: 100vh; z-index: 0; }
        
        /* Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }

        /* Animation classes */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin-custom { animation: spin 1s linear infinite; }
        
        /* Marker Styles */
        .custom-train-icon { transition: all 0.5s ease; }
        .station-dot { transition: all 0.3s ease; }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "jszip": "https://aistudiocdn.com/jszip@^3.10.1",
    "papaparse": "https://aistudiocdn.com/papaparse@^5.5.3",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.555.0",
    "vite": "https://aistudiocdn.com/vite@^7.2.6",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "leaflet": "https://aistudiocdn.com/leaflet@^1.9.4",
    "react-leaflet": "https://aistudiocdn.com/react-leaflet@^5.0.0"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <!-- 3. Application Logic -->
    <script type="text/babel">
        // --- CONSTANTS & HELPERS ---
        const { useState, useEffect, useRef, useMemo } = React;
        const CORS_PROXY = "https://api.allorigins.win/raw?url=";
        const RENFE_GTFS_URL = "https://ssl.renfe.com/gtransit/Fichero_AV_LD/google_transit.zip";

        // Simple Icons (Inline SVG to avoid dependency issues)
        const Icons = {
            Train: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="16" height="16" x="4" y="3" rx="2"/><path d="M4 11h16"/><path d="M12 3v8"/><path d="m8 19-2 3"/><path d="m18 22-2-3"/><path d="M8 15h0"/><path d="M16 15h0"/></svg>,
            Search: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>,
            Download: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>,
            Menu: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="m9 3 1 3h4l1-3"/><path d="M3 9h18"/><path d="m14 21-1-3H9l-1 3"/></svg>,
            Clock: () => <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        };

        const timeToSeconds = (timeStr) => {
            if (!timeStr) return 0;
            const parts = timeStr.split(':');
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + (parts[2] ? parseInt(parts[2]) : 0);
        };

        const formatTime = (seconds) => {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        };

        // --- GTFS PARSER ---
        const parseGTFSZip = async (file, onProgress) => {
            onProgress("Unzipping archive...");
            const zip = await JSZip.loadAsync(file);

            const readCSV = async (filename) => {
                const fileMatch = Object.keys(zip.files).find(path => path.endsWith(filename));
                if (!fileMatch) return [];
                const text = await zip.file(fileMatch).async('string');
                return new Promise(resolve => {
                    Papa.parse(text, {
                        header: true,
                        skipEmptyLines: true,
                        complete: (results) => resolve(results.data),
                    });
                });
            };

            onProgress("Parsing Calendar & Routes...");
            const [calendarRaw, calendarDatesRaw, routesRaw, stopsRaw, tripsRaw, stopTimesRaw] = await Promise.all([
                readCSV('calendar.txt'),
                readCSV('calendar_dates.txt'),
                readCSV('routes.txt'),
                readCSV('stops.txt'),
                readCSV('trips.txt'),
                readCSV('stop_times.txt')
            ]);

            onProgress("Processing Data Structures...");

            // Maps for fast lookup
            const calendar = new Map(calendarRaw.map(c => [c.service_id, c]));
            const calendarDates = new Map();
            calendarDatesRaw.forEach(cd => {
                if (!calendarDates.has(cd.service_id)) calendarDates.set(cd.service_id, []);
                calendarDates.get(cd.service_id).push(cd);
            });

            const routes = new Map(routesRaw.map(r => [r.route_id, r]));
            
            const stops = new Map(stopsRaw.map(s => [s.stop_id, {
                ...s,
                stop_lat: parseFloat(s.stop_lat),
                stop_lon: parseFloat(s.stop_lon)
            }]));

            const trips = new Map(tripsRaw.map(t => [t.trip_id, t]));

            const stopTimes = new Map();
            stopTimesRaw.forEach(st => {
                if (!trips.has(st.trip_id)) return;
                const processed = {
                    ...st,
                    stop_sequence: parseInt(st.stop_sequence),
                    arrival_seconds: timeToSeconds(st.arrival_time),
                    departure_seconds: timeToSeconds(st.departure_time),
                };
                if (!stopTimes.has(st.trip_id)) stopTimes.set(st.trip_id, []);
                stopTimes.get(st.trip_id).push(processed);
            });

            // Sort stop times
            for (const times of stopTimes.values()) {
                times.sort((a, b) => a.stop_sequence - b.stop_sequence);
            }

            return { calendar, calendarDates, routes, stops, trips, stopTimes };
        };

        const getActiveTrips = (gtfs, date) => {
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const todayStr = days[date.getDay()];
            const yyyy = date.getFullYear().toString();
            const mm = (date.getMonth() + 1).toString().padStart(2, '0');
            const dd = date.getDate().toString().padStart(2, '0');
            const dateInt = parseInt(`${yyyy}${mm}${dd}`);
            const dateStr = `${yyyy}${mm}${dd}`;

            const activeServices = new Set();

            gtfs.calendar.forEach(cal => {
                if (dateInt >= parseInt(cal.start_date) && dateInt <= parseInt(cal.end_date)) {
                    if (cal[todayStr] === '1') activeServices.add(cal.service_id);
                }
            });

            if (gtfs.calendarDates) {
                gtfs.calendarDates.forEach((dates, serviceId) => {
                    dates.forEach(d => {
                        if (d.date === dateStr) {
                            if (d.exception_type === '1') activeServices.add(serviceId);
                            else if (d.exception_type === '2') activeServices.delete(serviceId);
                        }
                    });
                });
            }

            return Array.from(gtfs.trips.values())
                .filter(t => activeServices.has(t.service_id))
                .map(t => t.trip_id);
        };

        // --- TRAIN SIMULATOR ---
        const getMadridSeconds = () => {
            const now = new Date();
            const madridTime = now.toLocaleTimeString('en-GB', { timeZone: 'Europe/Madrid', hour12: false });
            const [h, m, s] = madridTime.split(':').map(Number);
            return h * 3600 + m * 60 + s;
        };

        const interpolate = (start, end, fraction) => start + (end - start) * fraction;

        const getBearing = (lat1, lon1, lat2, lon2) => {
            const toRad = deg => deg * Math.PI / 180;
            const toDeg = rad => rad * 180 / Math.PI;
            const dLon = toRad(lon2 - lon1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            return (toDeg(Math.atan2(y, x)) + 360) % 360;
        };

        const calculatePositions = (gtfs, activeTripIds, currentSeconds) => {
            const positions = [];
            
            for (const tripId of activeTripIds) {
                const times = gtfs.stopTimes.get(tripId);
                if (!times || times.length < 2) continue;

                // Simple bounds check
                if (currentSeconds < times[0].departure_seconds) continue;
                if (currentSeconds > times[times.length - 1].arrival_seconds) continue;

                for (let i = 0; i < times.length - 1; i++) {
                    const current = times[i];
                    const next = times[i + 1];

                    // At Stop
                    if (currentSeconds >= current.arrival_seconds && currentSeconds <= current.departure_seconds) {
                        const stop = gtfs.stops.get(current.stop_id);
                        if (stop) {
                            positions.push({
                                trip_id: tripId,
                                lat: stop.stop_lat,
                                lng: stop.stop_lon,
                                bearing: 0,
                                status: 'AT_STOP',
                                nextStop: gtfs.stops.get(next.stop_id),
                                route: gtfs.routes.get(gtfs.trips.get(tripId).route_id),
                                trip: gtfs.trips.get(tripId)
                            });
                        }
                        break;
                    }

                    // Moving
                    if (currentSeconds > current.departure_seconds && currentSeconds < next.arrival_seconds) {
                        const stopA = gtfs.stops.get(current.stop_id);
                        const stopB = gtfs.stops.get(next.stop_id);
                        if (stopA && stopB) {
                            const duration = next.arrival_seconds - current.departure_seconds;
                            const elapsed = currentSeconds - current.departure_seconds;
                            const fraction = elapsed / duration;
                            
                            positions.push({
                                trip_id: tripId,
                                lat: interpolate(stopA.stop_lat, stopB.stop_lat, fraction),
                                lng: interpolate(stopA.stop_lon, stopB.stop_lon, fraction),
                                bearing: getBearing(stopA.stop_lat, stopA.stop_lon, stopB.stop_lat, stopB.stop_lon),
                                status: 'MOVING',
                                nextStop: stopB,
                                route: gtfs.routes.get(gtfs.trips.get(tripId).route_id),
                                trip: gtfs.trips.get(tripId)
                            });
                        }
                        break;
                    }
                }
            }
            return positions;
        };

        // --- COMPONENTS ---

        const Sidebar = ({ isOpen, setIsOpen, selectedTrain, selectedStation, searchTerm, onSearch, gtfsData, activeCount, timeStr, onCloseSel }) => {
            const trip = selectedTrain?.trip;
            const route = selectedTrain?.route;
            const stops = selectedTrain ? gtfsData.stopTimes.get(selectedTrain.trip_id) : [];

            return (
                <>
                    {!isOpen && (
                        <button onClick={() => setIsOpen(true)} className="absolute top-4 left-4 z-[500] bg-white p-3 rounded-lg shadow-lg hover:bg-gray-50">
                            <Icons.Menu />
                        </button>
                    )}
                    <div className={`absolute top-0 left-0 h-full bg-white shadow-2xl z-[1000] transition-all duration-300 flex flex-col w-96 ${isOpen ? 'translate-x-0' : '-translate-x-full'}`}>
                        {/* Header */}
                        <div className="p-4 border-b bg-slate-50">
                            <div className="flex justify-between items-center mb-4">
                                <h1 className="font-bold text-xl text-slate-800 flex items-center gap-2">
                                    <span className="text-purple-600"><Icons.Train /></span> Renfe Live
                                </h1>
                                <button onClick={() => setIsOpen(false)} className="p-1 hover:bg-gray-200 rounded"><Icons.X /></button>
                            </div>
                            
                            <form onSubmit={(e) => { e.preventDefault(); onSearch(searchTerm); }} className="relative mb-2">
                                <input 
                                    type="text" 
                                    placeholder="Search train # or station..." 
                                    className="w-full pl-10 pr-4 py-2 border rounded-lg focus:ring-2 focus:ring-purple-500 outline-none"
                                    value={searchTerm}
                                    onChange={(e) => onSearch(e.target.value)}
                                />
                                <span className="absolute left-3 top-2.5 text-gray-400"><Icons.Search /></span>
                            </form>
                            
                            <div className="flex justify-between text-xs text-slate-500 font-mono">
                                <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span> {activeCount} Active</span>
                                <span>{timeStr}</span>
                            </div>
                        </div>

                        {/* Content */}
                        <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                            {!selectedTrain && !selectedStation && (
                                <div className="text-center mt-10 text-slate-500">
                                    <div className="mx-auto w-16 h-16 bg-purple-50 rounded-full flex items-center justify-center mb-4 text-purple-400"><Icons.Search /></div>
                                    <p>Search for a train (e.g. 03102) or click a marker.</p>
                                </div>
                            )}

                            {selectedStation && (
                                <div>
                                    <div className="flex justify-between items-start mb-4">
                                        <h2 className="text-xl font-bold">{selectedStation.stop_name}</h2>
                                        <button onClick={onCloseSel}><Icons.X /></button>
                                    </div>
                                    <div className="bg-blue-50 text-blue-800 p-3 rounded text-sm">
                                        Station ID: {selectedStation.stop_id}
                                    </div>
                                </div>
                            )}

                            {selectedTrain && (
                                <div>
                                     <div className="flex justify-between items-start mb-2">
                                        <div>
                                            <span className="text-xs font-bold px-2 py-0.5 rounded text-white mb-1 inline-block" style={{background: route?.route_color ? '#' + route.route_color : '#7c3aed'}}>
                                                {route?.route_short_name}
                                            </span>
                                            <h2 className="text-lg font-bold">{trip?.trip_headsign}</h2>
                                            <p className="text-sm text-gray-500">Train #{trip?.trip_short_name}</p>
                                        </div>
                                        <button onClick={onCloseSel}><Icons.X /></button>
                                    </div>

                                    {selectedTrain.status === 'SCHEDULED' && (
                                        <div className="bg-orange-100 text-orange-800 p-2 rounded text-xs mb-4">
                                            Not currently running. Showing scheduled path.
                                        </div>
                                    )}

                                    <div className="relative border-l-2 border-slate-200 ml-2 mt-4 space-y-6">
                                        {stops.map((stop, i) => {
                                            const sInfo = gtfsData.stops.get(stop.stop_id);
                                            const isNext = selectedTrain.nextStop?.stop_id === stop.stop_id;
                                            return (
                                                <div key={i} className="ml-4 relative">
                                                    <div className={`absolute -left-[21px] top-1 w-3 h-3 rounded-full border-2 ${isNext ? 'bg-blue-500 border-blue-500 ring-4 ring-blue-100' : 'bg-white border-gray-300'}`}></div>
                                                    <div className={isNext ? 'font-bold text-slate-900' : 'text-slate-600'}>
                                                        {sInfo?.stop_name}
                                                    </div>
                                                    <div className="text-xs text-gray-400 font-mono">
                                                        {formatTime(stop.departure_seconds || stop.arrival_seconds)}
                                                    </div>
                                                </div>
                                            )
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </>
            );
        };

        const MapComponent = ({ stops, trains, onSelectTrain, onSelectStation, selectedTrainId, selectedStationId }) => {
            const mapRef = useRef(null);
            const markersRef = useRef({});
            const trainMarkersRef = useRef({});

            // Init Map
            useEffect(() => {
                if (!mapRef.current) {
                    const map = L.map('map', { zoomControl: false }).setView([40.4168, -3.7038], 6);
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '© OpenStreetMap contributors'
                    }).addTo(map);
                    mapRef.current = map;
                }
            }, []);

            // Render Stations (Static)
            useEffect(() => {
                if (!mapRef.current || stops.length === 0) return;
                
                // Clear existing station markers if data changes significantly (unlikely here)
                // Assuming static stops don't change often, we just add them once.
                
                stops.forEach(stop => {
                    if (markersRef.current[stop.stop_id]) return; // Already exists

                    const icon = L.divIcon({
                        className: 'station-icon',
                        html: `<div style="width:10px;height:10px;background:#64748b;border-radius:50%;border:2px solid white;box-shadow:0 1px 2px rgba(0,0,0,0.2);"></div>`,
                        iconSize: [10, 10],
                        iconAnchor: [5, 5]
                    });

                    const marker = L.marker([stop.stop_lat, stop.stop_lon], { icon })
                        .bindPopup(stop.stop_name)
                        .on('click', () => onSelectStation(stop))
                        .addTo(mapRef.current);
                    
                    markersRef.current[stop.stop_id] = marker;
                });
            }, [stops]);

            // Render Trains (Dynamic)
            useEffect(() => {
                if (!mapRef.current) return;
                
                // Track current trip IDs to remove finished trains
                const currentTripIds = new Set();

                trains.forEach(train => {
                    currentTripIds.add(train.trip_id);
                    const isSelected = train.trip_id === selectedTrainId;
                    const color = train.route?.route_color ? '#' + train.route.route_color : '#7c3aed';
                    const scale = isSelected ? 1.5 : 1;
                    
                    // Train SVG Icon
                    const svg = `
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32" height="32" style="transform: rotate(${train.bearing}deg); filter: drop-shadow(0px 1px 2px rgba(0,0,0,0.3));">
                            <path fill="${color}" stroke="white" stroke-width="2" d="M16,2 L8,10 L8,24 C8,26.2 9.8,28 12,28 L20,28 C22.2,28 24,26.2 24,24 L24,10 L16,2 Z" />
                            <rect x="11" y="12" width="10" height="6" rx="1" fill="white" fill-opacity="0.8" />
                        </svg>
                    `;
                    
                    const icon = L.divIcon({
                        className: 'train-icon',
                        html: svg,
                        iconSize: [32 * scale, 32 * scale],
                        iconAnchor: [16 * scale, 16 * scale]
                    });

                    if (trainMarkersRef.current[train.trip_id]) {
                        // Update
                        const marker = trainMarkersRef.current[train.trip_id];
                        marker.setLatLng([train.lat, train.lng]);
                        marker.setIcon(icon);
                        marker.setZIndexOffset(isSelected ? 1000 : 100);
                    } else {
                        // Create
                        const marker = L.marker([train.lat, train.lng], { icon, zIndexOffset: 100 })
                            .on('click', () => onSelectTrain(train))
                            .addTo(mapRef.current);
                        trainMarkersRef.current[train.trip_id] = marker;
                    }
                });

                // Remove stale trains
                Object.keys(trainMarkersRef.current).forEach(id => {
                    if (!currentTripIds.has(id) && id !== selectedTrainId) { // Keep selected even if "finished" for a moment
                        trainMarkersRef.current[id].remove();
                        delete trainMarkersRef.current[id];
                    }
                });

            }, [trains, selectedTrainId]);

            // Fly to selection
            useEffect(() => {
                if (selectedStationId && markersRef.current[selectedStationId]) {
                    mapRef.current.flyTo(markersRef.current[selectedStationId].getLatLng(), 13);
                }
            }, [selectedStationId]);

            useEffect(() => {
                if (selectedTrainId && trainMarkersRef.current[selectedTrainId]) {
                    mapRef.current.flyTo(trainMarkersRef.current[selectedTrainId].getLatLng(), 10);
                }
            }, [selectedTrainId]);

            return <div id="map"></div>;
        };

        // --- MAIN APP ---
        const App = () => {
            const [gtfsData, setGtfsData] = useState(null);
            const [activeTrips, setActiveTrips] = useState([]);
            const [positions, setPositions] = useState([]);
            const [loading, setLoading] = useState(false);
            const [loadingMsg, setLoadingMsg] = useState("");
            const [error, setError] = useState("");
            const [timeStr, setTimeStr] = useState("00:00:00");
            
            const [selectedTrain, setSelectedTrain] = useState(null);
            const [selectedStation, setSelectedStation] = useState(null);
            const [isSidebarOpen, setIsSidebarOpen] = useState(true);
            const [searchTerm, setSearchTerm] = useState("");

            // Simulation Loop
            useEffect(() => {
                if (!gtfsData) return;
                const interval = setInterval(() => {
                    const now = new Date();
                    setTimeStr(now.toLocaleTimeString('es-ES', { timeZone: 'Europe/Madrid' }));
                    
                    const seconds = getMadridSeconds();
                    const newPositions = calculatePositions(gtfsData, activeTrips, seconds);
                    setPositions(newPositions);

                    // Update selection if moving
                    if (selectedTrain && selectedTrain.status === 'MOVING') {
                        const updated = newPositions.find(p => p.trip_id === selectedTrain.trip_id);
                        if (updated) setSelectedTrain(updated);
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, [gtfsData, activeTrips, selectedTrain]);

            const processData = async (data) => {
                setLoadingMsg("Calculating active services...");
                await new Promise(r => setTimeout(r, 100)); // allow UI update
                const now = new Date();
                const madridDate = new Date(now.toLocaleDateString('en-US', { timeZone: 'Europe/Madrid' }));
                const active = getActiveTrips(data, madridDate);
                setGtfsData(data);
                setActiveTrips(active);
                setLoading(false);
            };

            const handleUrl = async () => {
                try {
                    setLoading(true); setError(""); setLoadingMsg("Downloading (via proxy)...");
                    const res = await fetch(CORS_PROXY + encodeURIComponent(RENFE_GTFS_URL));
                    if (!res.ok) throw new Error("Network error");
                    const blob = await res.blob();
                    const data = await parseGTFSZip(blob, setLoadingMsg);
                    processData(data);
                } catch(e) { 
                    setError(e.message); setLoading(false); 
                }
            };

            const handleFile = async (file) => {
                try {
                    setLoading(true); setError(""); 
                    const data = await parseGTFSZip(file, setLoadingMsg);
                    processData(data);
                } catch(e) {
                     setError("Invalid Zip"); setLoading(false);
                }
            };

            const handleSearch = (term) => {
                setSearchTerm(term);
                if (!term || !gtfsData) return;
                const low = term.toLowerCase();

                // 1. Station
                const stop = Array.from(gtfsData.stops.values()).find(s => s.stop_name.toLowerCase().includes(low));
                if (stop) { setSelectedStation(stop); setSelectedTrain(null); setIsSidebarOpen(true); return; }

                // 2. Active Train
                const active = positions.find(p => p.trip.trip_short_name?.includes(low) || p.trip.trip_headsign?.toLowerCase().includes(low));
                if (active) { setSelectedTrain(active); setSelectedStation(null); setIsSidebarOpen(true); return; }

                // 3. Static Train
                const trip = Array.from(gtfsData.trips.values()).find(t => t.trip_short_name?.includes(low) || t.trip_headsign?.toLowerCase().includes(low));
                if (trip) {
                    const times = gtfsData.stopTimes.get(trip.trip_id);
                    if (times) {
                        const firstStop = gtfsData.stops.get(times[0].stop_id);
                        setSelectedTrain({
                            trip_id: trip.trip_id,
                            lat: firstStop.stop_lat, lng: firstStop.stop_lon, bearing: 0,
                            status: 'SCHEDULED',
                            route: gtfsData.routes.get(trip.route_id),
                            trip: trip
                        });
                        setSelectedStation(null); setIsSidebarOpen(true);
                    }
                }
            };

            // Drag Drop
            const onDrop = (e) => {
                e.preventDefault();
                if(e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            };

            if (loading) return (
                <div className="flex flex-col items-center justify-center h-screen bg-slate-50">
                     <div className="w-10 h-10 border-4 border-purple-600 border-t-transparent rounded-full animate-spin-custom mb-4"></div>
                     <p className="text-slate-600 font-mono">{loadingMsg}</p>
                </div>
            );

            if (!gtfsData) return (
                <div className="h-screen flex flex-col items-center justify-center bg-slate-50 p-6" onDragOver={e=>e.preventDefault()} onDrop={onDrop}>
                    <div className="bg-white p-10 rounded-3xl shadow-xl text-center max-w-lg w-full border border-slate-200">
                        <div className="w-20 h-20 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-6 text-purple-600">
                            <Icons.Train />
                        </div>
                        <h1 className="text-3xl font-bold text-slate-800 mb-2">Renfe AV/LD Tracker</h1>
                        <p className="text-slate-500 mb-8">Visualiza los trenes de Alta Velocidad y Larga Distancia en tiempo real.</p>
                        
                        {error && <div className="bg-red-50 text-red-600 p-3 rounded mb-4 text-sm">{error}</div>}

                        <div className="space-y-3">
                            <button onClick={handleUrl} className="w-full bg-purple-600 text-white py-4 rounded-xl font-bold hover:bg-purple-700 transition flex items-center justify-center gap-2">
                                <Icons.Download /> Cargar Datos Renfe
                            </button>
                            <div className="relative border-2 border-dashed border-slate-300 rounded-xl p-8 hover:bg-slate-50 transition cursor-pointer">
                                <input type="file" className="absolute inset-0 opacity-0 cursor-pointer" onChange={e => e.target.files[0] && handleFile(e.target.files[0])} />
                                <div className="text-slate-400 font-bold flex flex-col items-center gap-2">
                                    <Icons.Upload />
                                    <span>Arrastra el ZIP aquí</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );

            return (
                <div className="relative w-full h-full">
                    <Sidebar 
                        isOpen={isSidebarOpen} setIsOpen={setIsSidebarOpen}
                        selectedTrain={selectedTrain} selectedStation={selectedStation}
                        searchTerm={searchTerm} onSearch={handleSearch}
                        gtfsData={gtfsData} activeCount={positions.length} timeStr={timeStr}
                        onCloseSel={() => { setSelectedTrain(null); setSelectedStation(null); }}
                    />
                    <MapComponent 
                        stops={Array.from(gtfsData.stops.values())} 
                        trains={positions}
                        onSelectTrain={(t) => { setSelectedTrain(t); setSelectedStation(null); setIsSidebarOpen(true); }}
                        onSelectStation={(s) => { setSelectedStation(s); setSelectedTrain(null); setIsSidebarOpen(true); }}
                        selectedTrainId={selectedTrain?.trip_id}
                        selectedStationId={selectedStation?.stop_id}
                    />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>